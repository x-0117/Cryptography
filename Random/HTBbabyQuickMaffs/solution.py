# As per the encrypion algorithm, if we get a partition_list, p of length n, and remainder r,
# then p[0] = p[1] = ... = p[n - 2] and p[0] + r = p[n - 1]
# Let a = p[0] and b = p[n - 1]

# Original message = (n - 1) * a + r
# The partition_list :    [a,              a,             ... a             (n - 1 times), b]              (Not available)
# Corresponding ciphers : [a ** 2 (mod N), a ** 2 (mod N) ... a ** 2 (mod N)(n - 1 times), b ** 2 (mod N)] (Available to us)

# b = a + r
# b ** 2 = a ** 2 + r ** 2 + 2 * a * r
# (b ** 2) mod N = (a ** 2 + r ** 2 + 2 * a * r) mod N
# a = inverse(2 * r, N)(b ** 2 - a ** 2 - r ** 2) mod N
# a = inverse(2 * r, N)((b ** 2) mod N - (a ** 2) mod N - (r ** 2) mod N)
# a = inverse(2 * r, N)(ciphers[n - 1] - ciphers[0] - (r ** 2) mod N) mod N

# message = (n - 1) * a + r


from Crypto.Util.number import long_to_bytes
N = 6083782486455360611313889289556658208725888944237734041722591252756006664878102248734673207367745303402874595854966731263105387801996693270011840173939423
r = 1081087287982224274239399953615475281184099226198643053396569433856757255106426461817760194704250226883807897800355728788149068771546876055268915238961343
c = [5408283916250636369066846815501131861319520431106165986129813106223074286810632222888292034380612581416458756909119954039579666773680866532576166358987272, 5408283916250636369066846815501131861319520431106165986129813106223074286810632222888292034380612581416458756909119954039579666773680866532576166358987272, 5598555010250184271123226314796180406367795504188162611960100902143581636125416986623404842897202277277978566659455918773104687212096435095590205751904580]
a_2, b_2 = c[0], c[-1]
a = (pow(2 * r, -1, N) * (b_2 - a_2 - pow(r, 2, N))) % N
pt = a * (len(c) - 1) + r

print(long_to_bytes(pt))