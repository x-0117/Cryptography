# -*- coding: utf-8 -*-
import math, time
from Crypto.Util.number import long_to_bytes
n = 68410735253478047532669195609897926895002715632943461448660159313126496660033080937734557748701577020593482441014012783126085444004682764336220752851098517881202476417639649807333810261708210761333918442034275018088771547499619393557995773550772279857842207065696251926349053195423917250334982174308578108707
e = 65537
c = 4776006201999857533937746330553026200220638488579394063956998522022062232921285860886801454955588545654394710104334517021340109545003304904641820637316671869512340501549190724859489875329025743780939742424765825407663239591228764211985406490810832049380427145964590612241379808722737688823830921988891019862
# D(c)
dc = 58324527381741086207181449678831242444903897671571344216578285287377618832939516678686212825798172668450906644065483369735063383237979049248667084304630968896854046853486000780081390375682767386163384705607552367796490630893227401487357088304270489873369870382871693215188248166759293149916320915248800905458

# Since m is not coprime to n, pt != D(c)
# D(c) = (pt) ** (e * d)(mod n)
# p ** 8 | pt ** (e * d)
# D(c) - K * p**8 = k1 * (p ** 8 * q * r)                                  [pt ** (e * d) = K * p**8 (For some K)  n = p ** 8 * q * r]
# D(c) = K * p**8 - k1 * (p ** 8 * q * r) = p**8(K - k1 * q * r)
# Therefore, gcd(D(c), n) = p ** 8
g = math.gcd(n, c)

# From http://factordb.com/ we get p
p = 17649002407863577841

# q * r = (p ** 8 * q * r) / (p ** 8)
qr = n // g

# de = k * (p ** 7 * (p - 1) * (q - 1) * (r - 1)) + 1                   (1)[For some k]
# The padded cipher text m is such that p | m, Let, m = p * x
# D(c) = m ** (d*e) ≡ p ** (d*e) * x ** (d*e)(mod n)                       [n = p ** 8 * q * r]
# D(c) - p ** (d*e) * x ** (d*e) = c1 * p ** 8 * q * r                     [For some k1]
# D(c) // p**8 - p ** (e * d - 8) * x ** (d * e) = c1 * q * r              [p ** 8 | D(c), else the equation won't hold]
# D(c) // p**8 ≡ p ** (e * d - 8) * x ** (d * e)(mod q * r)             (2)
# e * d - 8 = k * (p ** 7 * (p - 1) * (q - 1) * (r - 1)) + 1 - 8           [From equation (1)]
# p ** (e * d - 8) = p ** (k * (p ** 7 * (p - 1) * (q - 1) * (r - 1)) - 7)
# p ** (e * d - 8) ≡ p ** (K * (q - 1) * (r - 1)) * p ** -8(mod q * r)     [K = p ** 7 * (p - 1)]
# p ** (e * d - 8) ≡ 1 * p ** -7(mod q * r)                                [p coprime to q * r]
# p ** (8 - e * d) ≡ p ** 7(mod q * r)                                  (3)

# Similarly, x ** (d * e) ≡ x(mod q * r)
# From (2) and (3), D(c) // p ≡ x ** (d * e)(mod q * r)
# x = (dc // p) % (q * r) + k * q * r

x = (dc // p) % qr

while True:
    # Found the solution for k = 0
    print(long_to_bytes((p * x)>>(512 // 8)))
    x += qr
    time.sleep(1)


# flag{y34_th1s_1s_n0t_h0w_mult1pr1m3_RS4_w0rks_buddy}
